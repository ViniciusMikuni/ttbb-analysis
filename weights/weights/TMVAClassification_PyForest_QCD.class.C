// Class: ReadPyForest_QCD
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : PyRandomForest::PyForest_QCD
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.12/04       [396292]
Creator        : viniciusmikuni
Date           : Mon Feb 26 14:08:11 2018
Host           : Darwin Viniciuss-MacBook-Pro.local 17.2.0 Darwin Kernel Version 17.2.0: Fri Sep 29 18:27:05 PDT 2017; root:xnu-4570.20.62~3/RELEASE_X86_64 x86_64
Dir            : /Users/viniciusmikuni/cernbox/CMS/ttbbAnalysis/KinFitter/test/MVA/BDT
Training events: 676958
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
NEstimators: "850" [Integer, optional (default=10). The number of trees in the forest.]
Criterion: "gini" [String, optional (default='gini')       The function to measure the quality of a split. Supported criteria are       'gini' for the Gini impurity and 'entropy' for the information gain.       Note: this parameter is tree-specific.]
MaxDepth: "6" [integer or None, optional (default=None)       The maximum depth of the tree. If None, then nodes are expanded until       all leaves are pure or until all leaves contain less than       min_samples_split samples.       Ignored if ``max_leaf_nodes`` is not None.]
MinSamplesLeaf: "1" [integer, optional (default=1)       The minimum number of samples in newly created leaves.  A split is       discarded if after the split, one of the leaves would contain less then       ``min_samples_leaf`` samples.]
MinWeightFractionLeaf: "0.000000e+00" [//float, optional (default=0.)       The minimum weighted fraction of the input samples required to be at a       leaf node.]
MaxFeatures: "'auto'" [The number of features to consider when looking for the best split]
Bootstrap: "True" [boolean, optional (default=True)       Whether bootstrap samples are used when building trees.]
# Default:
VerbosityLevel: "Default" [Verbosity level]
H: "False" [Print method-specific help message]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
Normalise: "False" [Normalise input variables]
D: "False" [Use-decorrelated-variables flag]
VarTransformType: "Signal" [Use signal or background events to derive for variable transformation (the transformation is applied on both types of, course)]
TxtWeightFilesOnly: "True" [If True: write all training results (weights) as text files (False: some are written in ROOT format)]
NbinsMVAPdf: "60" [Number of bins used for the PDFs of classifier outputs]
NsmoothMVAPdf: "2" [Number of smoothing iterations for classifier PDFs]
MinSamplesSplit: "2" [integer, optional (default=2)      The minimum number of samples required to split an internal node.]
MaxLeafNodes: "None" [int or None, optional (default=None)      Grow trees with ``max_leaf_nodes`` in best-first fashion.      Best nodes are defined as relative reduction in impurity.      If None then unlimited number of leaf nodes.      If not None then ``max_depth`` will be ignored.]
OoBScore: "False" [ bool Whether to use out-of-bag samples to estimate      the generalization error.]
NJobs: "1" [ integer, optional (default=1)       The number of jobs to run in parallel for both `fit` and `predict`.       If -1, then the number of jobs is set to the number of cores.]
RandomState: "None" [int, RandomState instance or None, optional (default=None)      If int, random_state is the seed used by the random number generator;      If RandomState instance, random_state is the random number generator;      If None, the random number generator is the RandomState instance used      by `np.random`.]
Verbose: "0" [int, optional (default=0)      Controls the verbosity of the tree building process.]
WarmStart: "False" [bool, optional (default=False)      When set to ``True``, reuse the solution of the previous call to fit      and add more estimators to the ensemble, otherwise, just fit a whole      new forest.]
ClassWeight: "None" [dict, list of dicts, "auto", "subsample" or None, optional      Weights associated with classes in the form ``{class_label: weight}``.      If not given, all classes are supposed to have weight one. For      multi-output problems, a list of dicts can be provided in the same      order as the columns of y.      The "auto" mode uses the values of y to automatically adjust      weights inversely proportional to class frequencies in the input data.      The "subsample" mode is the same as "auto" except that weights are      computed based on the bootstrap sample for every tree grown.      For multi-output, the weights of each column of y will be multiplied.      Note that these weights will be multiplied with sample_weight (passed      through the fit method) if sample_weight is specified.]
FilenameClassifier: "MVA_weights/weights/PyRFModel_PyForest_QCD.PyData" [Store trained classifier in this file]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 50
tt_m                          tt_m                          tt_m                          tt_m                                                            'F'    [209.034347534,4321.18798828]
tt_pt                         tt_pt                         tt_pt                         tt_pt                                                           'F'    [0.479255348444,1692.54125977]
lq1_m                         lq1_m                         lq1_m                         lq1_m                                                           'F'    [1.00911092758,129.007965088]
lq1_pt                        lq1_pt                        lq1_pt                        lq1_pt                                                          'F'    [30.0324363708,985.517578125]
lq2_m                         lq2_m                         lq2_m                         lq2_m                                                           'F'    [0.271055966616,43.9188652039]
lq2_pt                        lq2_pt                        lq2_pt                        lq2_pt                                                          'F'    [30.0000743866,290.655456543]
lp1_m                         lp1_m                         lp1_m                         lp1_m                                                           'F'    [0.658180654049,133.462814331]
lp1_pt                        lp1_pt                        lp1_pt                        lp1_pt                                                          'F'    [30.0507965088,1223.41235352]
lp2_m                         lp2_m                         lp2_m                         lp2_m                                                           'F'    [0.353440970182,44.4416847229]
lp2_pt                        lp2_pt                        lp2_pt                        lp2_pt                                                          'F'    [30.0000629425,297.517944336]
w1_m                          w1_m                          w1_m                          w1_m                                                            'F'    [17.2404918671,176.347305298]
w1_pt                         w1_pt                         w1_pt                         w1_pt                                                           'F'    [0.215049341321,1013.98321533]
w2_m                          w2_m                          w2_m                          w2_m                                                            'F'    [17.5608940125,176.388336182]
w2_pt                         w2_pt                         w2_pt                         w2_pt                                                           'F'    [0.0714365616441,1264.9107666]
top1_m                        top1_m                        top1_m                        top1_m                                                          'F'    [65.6817092896,288.599060059]
top1_pt                       top1_pt                       top1_pt                       top1_pt                                                         'F'    [0.670812964439,1712.74890137]
top2_m                        top2_m                        top2_m                        top2_m                                                          'F'    [65.8645935059,288.756622314]
top2_pt                       top2_pt                       top2_pt                       top2_pt                                                         'F'    [0.477588117123,1296.76489258]
prob_chi2                     prob_chi2                     prob_chi2                     prob_chi2                                                       'F'    [1.00004092474e-06,0.999999284744]
BDT_Comb                      BDT_Comb                      BDT_Comb                      BDT_Comb                                                        'F'    [-0.998794496059,0.988075017929]
jet5pt                        jet5pt                        jet5pt                        jet5pt                                                          'F'    [40.0000305176,335.457458496]
n_jets                        n_jets                        n_jets                        n_jets                                                          'I'    [7,16]
simple_chi2                   simple_chi2                   simple_chi2                   simple_chi2                                                     'F'    [0.002432764275,33.3767547607]
btagLR3b                      btagLR3b                      btagLR3b                      btagLR3b                                                        'F'    [0.180864900351,0.99770450592]
aplanarity                    aplanarity                    aplanarity                    aplanarity                                                      'F'    [0.000137362614623,0.458270043135]
p1b2_mass                     p1b2_mass                     p1b2_mass                     p1b2_mass                                                       'F'    [0,270.584777832]
q1b1_mass                     q1b1_mass                     q1b1_mass                     q1b1_mass                                                       'F'    [0,274.126098633]
ht                            ht                            ht                            ht                                                              'F'    [500.001708984,4577.13671875]
closest_mass                  closest_mass                  closest_mass                  closest_mass                                                    'F'    [14.7909955978,122.849555969]
jets_dRavg                    jets_dRavg                    jets_dRavg                    jets_dRavg                                                      'F'    [0.85890775919,3.41847443581]
meanCSVbtag                   meanCSVbtag                   meanCSVbtag                   meanCSVbtag                                                     'F'    [-2.21004128456,0.946745812893]
all_mass                      all_mass                      all_mass                      all_mass                                                        'F'    [412.977722168,6784.65966797]
jet_CSV[0]                    jet_CSV_0_                    jet_CSV[0]                    jet_CSV[0]                                                      'F'    [0,1]
jet_CSV[1]                    jet_CSV_1_                    jet_CSV[1]                    jet_CSV[1]                                                      'F'    [0,1]
jet_CSV[2]                    jet_CSV_2_                    jet_CSV[2]                    jet_CSV[2]                                                      'F'    [0,0.999595880508]
jet_CSV[3]                    jet_CSV_3_                    jet_CSV[3]                    jet_CSV[3]                                                      'F'    [0,0.999581336975]
jet_CSV[4]                    jet_CSV_4_                    jet_CSV[4]                    jet_CSV[4]                                                      'F'    [0,0.999582052231]
jet_CSV[5]                    jet_CSV_5_                    jet_CSV[5]                    jet_CSV[5]                                                      'F'    [0,0.999603807926]
jet_QGL[0]                    jet_QGL_0_                    jet_QGL[0]                    jet_QGL[0]                                                      'F'    [0,1]
jet_QGL[1]                    jet_QGL_1_                    jet_QGL[1]                    jet_QGL[1]                                                      'F'    [0,1]
jet_QGL[2]                    jet_QGL_2_                    jet_QGL[2]                    jet_QGL[2]                                                      'F'    [0,1]
jet_QGL[3]                    jet_QGL_3_                    jet_QGL[3]                    jet_QGL[3]                                                      'F'    [0,1]
jet_QGL[4]                    jet_QGL_4_                    jet_QGL[4]                    jet_QGL[4]                                                      'F'    [0,1]
jet_QGL[5]                    jet_QGL_5_                    jet_QGL[5]                    jet_QGL[5]                                                      'F'    [0,1]
jet_MOverPt[0]                jet_MOverPt_0_                jet_MOverPt[0]                jet_MOverPt[0]                                                  'F'    [0,0.325008362532]
jet_MOverPt[1]                jet_MOverPt_1_                jet_MOverPt[1]                jet_MOverPt[1]                                                  'F'    [0,0.338414132595]
jet_MOverPt[2]                jet_MOverPt_2_                jet_MOverPt[2]                jet_MOverPt[2]                                                  'F'    [0,0.325283885002]
jet_MOverPt[3]                jet_MOverPt_3_                jet_MOverPt[3]                jet_MOverPt[3]                                                  'F'    [0,0.338659197092]
jet_MOverPt[4]                jet_MOverPt_4_                jet_MOverPt[4]                jet_MOverPt[4]                                                  'F'    [0,0.316506683826]
jet_MOverPt[5]                jet_MOverPt_5_                jet_MOverPt[5]                jet_MOverPt[5]                                                  'F'    [0,0.331616908312]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadPyForest_QCD : public IClassifierReader {

 public:

   // constructor
   ReadPyForest_QCD( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadPyForest_QCD" ),
        fNvars( 50 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "tt_m", "tt_pt", "lq1_m", "lq1_pt", "lq2_m", "lq2_pt", "lp1_m", "lp1_pt", "lp2_m", "lp2_pt", "w1_m", "w1_pt", "w2_m", "w2_pt", "top1_m", "top1_pt", "top2_m", "top2_pt", "prob_chi2", "BDT_Comb", "jet5pt", "n_jets", "simple_chi2", "btagLR3b", "aplanarity", "p1b2_mass", "q1b1_mass", "ht", "closest_mass", "jets_dRavg", "meanCSVbtag", "all_mass", "jet_CSV[0]", "jet_CSV[1]", "jet_CSV[2]", "jet_CSV[3]", "jet_CSV[4]", "jet_CSV[5]", "jet_QGL[0]", "jet_QGL[1]", "jet_QGL[2]", "jet_QGL[3]", "jet_QGL[4]", "jet_QGL[5]", "jet_MOverPt[0]", "jet_MOverPt[1]", "jet_MOverPt[2]", "jet_MOverPt[3]", "jet_MOverPt[4]", "jet_MOverPt[5]" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;
      fVmin[20] = 0;
      fVmax[20] = 0;
      fVmin[21] = 0;
      fVmax[21] = 0;
      fVmin[22] = 0;
      fVmax[22] = 0;
      fVmin[23] = 0;
      fVmax[23] = 0;
      fVmin[24] = 0;
      fVmax[24] = 0;
      fVmin[25] = 0;
      fVmax[25] = 0;
      fVmin[26] = 0;
      fVmax[26] = 0;
      fVmin[27] = 0;
      fVmax[27] = 0;
      fVmin[28] = 0;
      fVmax[28] = 0;
      fVmin[29] = 0;
      fVmax[29] = 0;
      fVmin[30] = 0;
      fVmax[30] = 0;
      fVmin[31] = 0;
      fVmax[31] = 0;
      fVmin[32] = 0;
      fVmax[32] = 0;
      fVmin[33] = 0;
      fVmax[33] = 0;
      fVmin[34] = 0;
      fVmax[34] = 0;
      fVmin[35] = 0;
      fVmax[35] = 0;
      fVmin[36] = 0;
      fVmax[36] = 0;
      fVmin[37] = 0;
      fVmax[37] = 0;
      fVmin[38] = 0;
      fVmax[38] = 0;
      fVmin[39] = 0;
      fVmax[39] = 0;
      fVmin[40] = 0;
      fVmax[40] = 0;
      fVmin[41] = 0;
      fVmax[41] = 0;
      fVmin[42] = 0;
      fVmax[42] = 0;
      fVmin[43] = 0;
      fVmax[43] = 0;
      fVmin[44] = 0;
      fVmax[44] = 0;
      fVmin[45] = 0;
      fVmax[45] = 0;
      fVmin[46] = 0;
      fVmax[46] = 0;
      fVmin[47] = 0;
      fVmax[47] = 0;
      fVmin[48] = 0;
      fVmax[48] = 0;
      fVmin[49] = 0;
      fVmax[49] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';
      fType[17] = 'F';
      fType[18] = 'F';
      fType[19] = 'F';
      fType[20] = 'F';
      fType[21] = 'I';
      fType[22] = 'F';
      fType[23] = 'F';
      fType[24] = 'F';
      fType[25] = 'F';
      fType[26] = 'F';
      fType[27] = 'F';
      fType[28] = 'F';
      fType[29] = 'F';
      fType[30] = 'F';
      fType[31] = 'F';
      fType[32] = 'F';
      fType[33] = 'F';
      fType[34] = 'F';
      fType[35] = 'F';
      fType[36] = 'F';
      fType[37] = 'F';
      fType[38] = 'F';
      fType[39] = 'F';
      fType[40] = 'F';
      fType[41] = 'F';
      fType[42] = 'F';
      fType[43] = 'F';
      fType[44] = 'F';
      fType[45] = 'F';
      fType[46] = 'F';
      fType[47] = 'F';
      fType[48] = 'F';
      fType[49] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadPyForest_QCD() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[50];
   double fVmax[50];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[50];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   inline double ReadPyForest_QCD::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
