// Class: ReadPyForest_comb
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : PyRandomForest::PyForest_comb
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.11/03       [396035]
Creator        : viniciusmikuni
Date           : Sun Jan 21 19:14:01 2018
Host           : Darwin dhcp-164-190.uzh.ch 16.7.0 Darwin Kernel Version 16.7.0: Thu Jun 15 17:36:27 PDT 2017; root:xnu-3789.70.16~2/RELEASE_X86_64 x86_64
Dir            : /Users/viniciusmikuni/cernbox/CMS/ttbbAnalysis/KinFitter/test/MVA/BDT
Training events: 556025
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
NEstimators: "850" [Integer, optional (default=10). The number of trees in the forest.]
Criterion: "gini" [String, optional (default='gini')       The function to measure the quality of a split. Supported criteria are       'gini' for the Gini impurity and 'entropy' for the information gain.       Note: this parameter is tree-specific.]
MaxDepth: "6" [integer or None, optional (default=None)       The maximum depth of the tree. If None, then nodes are expanded until       all leaves are pure or until all leaves contain less than       min_samples_split samples.       Ignored if ``max_leaf_nodes`` is not None.]
MinSamplesLeaf: "1" [integer, optional (default=1)       The minimum number of samples in newly created leaves.  A split is       discarded if after the split, one of the leaves would contain less then       ``min_samples_leaf`` samples.]
MinWeightFractionLeaf: "0.000000e+00" [//float, optional (default=0.)       The minimum weighted fraction of the input samples required to be at a       leaf node.]
MaxFeatures: "'auto'" [The number of features to consider when looking for the best split]
Bootstrap: "True" [boolean, optional (default=True)       Whether bootstrap samples are used when building trees.]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
H: "False" [Print method-specific help message]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
Normalise: "False" [Normalise input variables]
D: "False" [Use-decorrelated-variables flag]
VarTransformType: "Signal" [Use signal or background events to derive for variable transformation (the transformation is applied on both types of, course)]
TxtWeightFilesOnly: "True" [If True: write all training results (weights) as text files (False: some are written in ROOT format)]
NbinsMVAPdf: "60" [Number of bins used for the PDFs of classifier outputs]
NsmoothMVAPdf: "2" [Number of smoothing iterations for classifier PDFs]
MinSamplesSplit: "2" [integer, optional (default=2)      The minimum number of samples required to split an internal node.]
MaxLeafNodes: "None" [int or None, optional (default=None)      Grow trees with ``max_leaf_nodes`` in best-first fashion.      Best nodes are defined as relative reduction in impurity.      If None then unlimited number of leaf nodes.      If not None then ``max_depth`` will be ignored.]
OoBScore: "False" [ bool Whether to use out-of-bag samples to estimate      the generalization error.]
NJobs: "1" [ integer, optional (default=1)       The number of jobs to run in parallel for both `fit` and `predict`.       If -1, then the number of jobs is set to the number of cores.]
RandomState: "None" [int, RandomState instance or None, optional (default=None)      If int, random_state is the seed used by the random number generator;      If RandomState instance, random_state is the random number generator;      If None, the random number generator is the RandomState instance used      by `np.random`.]
Verbose: "0" [int, optional (default=0)      Controls the verbosity of the tree building process.]
WarmStart: "False" [bool, optional (default=False)      When set to ``True``, reuse the solution of the previous call to fit      and add more estimators to the ensemble, otherwise, just fit a whole      new forest.]
ClassWeight: "None" [dict, list of dicts, "auto", "subsample" or None, optional      Weights associated with classes in the form ``{class_label: weight}``.      If not given, all classes are supposed to have weight one. For      multi-output problems, a list of dicts can be provided in the same      order as the columns of y.      The "auto" mode uses the values of y to automatically adjust      weights inversely proportional to class frequencies in the input data.      The "subsample" mode is the same as "auto" except that weights are      computed based on the bootstrap sample for every tree grown.      For multi-output, the weights of each column of y will be multiplied.      Note that these weights will be multiplied with sample_weight (passed      through the fit method) if sample_weight is specified.]
FilenameClassifier: "MVA_weights/weights/PyRFModel_PyForest_comb.PyData" [Store trained classifier in this file]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 44
top1_m                        top1_m                        top1_m                        top1_m                                                          'F'    [85.3179244995,270.135345459]
top2_m                        top2_m                        top2_m                        top2_m                                                          'F'    [82.5143356323,270.098358154]
w1_m                          w1_m                          w1_m                          w1_m                                                            'F'    [20.3302898407,156.997772217]
w2_m                          w2_m                          w2_m                          w2_m                                                            'F'    [17.1665668488,160.585571289]
b1_pt                         b1_pt                         b1_pt                         b1_pt                                                           'F'    [63.7008361816,756.699829102]
b2_pt                         b2_pt                         b2_pt                         b2_pt                                                           'F'    [40.3511924744,663.071594238]
deltaRl1l2                    deltaRl1l2                    deltaRl1l2                    deltaRl1l2                                                      'F'    [0.395003288984,3.65274238586]
deltaRq1q2                    deltaRq1q2                    deltaRq1q2                    deltaRq1q2                                                      'F'    [0.38800778985,4.12837219238]
deltaRb1b2                    deltaRb1b2                    deltaRb1b2                    deltaRb1b2                                                      'F'    [0.401552975178,5.46203327179]
deltaRb1w1                    deltaRb1w1                    deltaRb1w1                    deltaRb1w1                                                      'F'    [0.00076783366967,7.10167455673]
deltaRb2w2                    deltaRb2w2                    deltaRb2w2                    deltaRb2w2                                                      'F'    [0.000467266858323,7.60575246811]
deltaPhil1l2                  deltaPhil1l2                  deltaPhil1l2                  deltaPhil1l2                                                    'F'    [-3.14156842232,3.14155817032]
deltaPhiq1q2                  deltaPhiq1q2                  deltaPhiq1q2                  deltaPhiq1q2                                                    'F'    [-3.14157986641,3.14158630371]
deltaPhib1b2                  deltaPhib1b2                  deltaPhib1b2                  deltaPhib1b2                                                    'F'    [-3.14157938957,3.14157938957]
deltaPhiw1w2                  deltaPhiw1w2                  deltaPhiw1w2                  deltaPhiw1w2                                                    'F'    [-3.14158511162,3.14159226418]
deltaPhit1t2                  deltaPhit1t2                  deltaPhit1t2                  deltaPhit1t2                                                    'F'    [-3.14159226418,3.14159250259]
q1b1_mass                     q1b1_mass                     q1b1_mass                     q1b1_mass                                                       'F'    [34.759349823,252.734634399]
p1b2_mass                     p1b2_mass                     p1b2_mass                     p1b2_mass                                                       'F'    [25.7791805267,253.003082275]
deltaRb1q1                    deltaRb1q1                    deltaRb1q1                    deltaRb1q1                                                      'F'    [0.378494590521,3.59525156021]
deltaRb2p1                    deltaRb2p1                    deltaRb2p1                    deltaRb2p1                                                      'F'    [0.392402678728,4.26794672012]
deltaRb1top2                  deltaRb1top2                  deltaRb1top2                  deltaRb1top2                                                    'F'    [0.0112846512347,7.48146915436]
deltaRb2top1                  deltaRb2top1                  deltaRb2top1                  deltaRb2top1                                                    'F'    [0.011580824852,6.99938392639]
deltaRb1w2                    deltaRb1w2                    deltaRb1w2                    deltaRb1w2                                                      'F'    [0.00335044087842,8.5753698349]
deltaRb2w1                    deltaRb2w1                    deltaRb2w1                    deltaRb2w1                                                      'F'    [0.0104703484103,9.20963191986]
mindeltaRb1q                  mindeltaRb1q                  mindeltaRb1q                  mindeltaRb1q                                                    'F'    [0.378494590521,3.21266770363]
prob_chi2                     prob_chi2                     prob_chi2                     prob_chi2                                                       'F'    [0.00010000023758,0.99998831749]
mindeltaRb2p                  mindeltaRb2p                  mindeltaRb2p                  mindeltaRb2p                                                    'F'    [0.38800778985,3.53099155426]
deltaEtal1l2                  deltaEtal1l2                  deltaEtal1l2                  deltaEtal1l2                                                    'F'    [7.21216201782e-06,2.59078598022]
deltaEtaq1q2                  deltaEtaq1q2                  deltaEtaq1q2                  deltaEtaq1q2                                                    'F'    [3.33786010742e-06,3.10397624969]
deltaEtab1b2                  deltaEtab1b2                  deltaEtab1b2                  deltaEtab1b2                                                    'F'    [2.20909714699e-06,4.61412382126]
deltaEtaw1w2                  deltaEtaw1w2                  deltaEtaw1w2                  deltaEtaw1w2                                                    'F'    [-9.2188205719,8.74718284607]
deltaEtat1t2                  deltaEtat1t2                  deltaEtat1t2                  deltaEtat1t2                                                    'F'    [-8.17296123505,8.28463077545]
jet_CSV[0]                    jet_CSV_0_                    jet_CSV[0]                    jet_CSV[0]                                                      'F'    [-10,0.999300420284]
jet_CSV[1]                    jet_CSV_1_                    jet_CSV[1]                    jet_CSV[1]                                                      'F'    [-10,1]
jet_CSV[2]                    jet_CSV_2_                    jet_CSV[2]                    jet_CSV[2]                                                      'F'    [-10,1]
jet_CSV[3]                    jet_CSV_3_                    jet_CSV[3]                    jet_CSV[3]                                                      'F'    [-10,0.999636054039]
jet_CSV[4]                    jet_CSV_4_                    jet_CSV[4]                    jet_CSV[4]                                                      'F'    [-10,1]
jet_CSV[5]                    jet_CSV_5_                    jet_CSV[5]                    jet_CSV[5]                                                      'F'    [-10,1]
jet_QGL[0]                    jet_QGL_0_                    jet_QGL[0]                    jet_QGL[0]                                                      'F'    [-1,1]
jet_QGL[1]                    jet_QGL_1_                    jet_QGL[1]                    jet_QGL[1]                                                      'F'    [-1,1]
jet_QGL[2]                    jet_QGL_2_                    jet_QGL[2]                    jet_QGL[2]                                                      'F'    [-1,1]
jet_QGL[3]                    jet_QGL_3_                    jet_QGL[3]                    jet_QGL[3]                                                      'F'    [-20,1]
jet_QGL[4]                    jet_QGL_4_                    jet_QGL[4]                    jet_QGL[4]                                                      'F'    [-20,1]
jet_QGL[5]                    jet_QGL_5_                    jet_QGL[5]                    jet_QGL[5]                                                      'F'    [-20,1]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadPyForest_comb : public IClassifierReader {

 public:

   // constructor
   ReadPyForest_comb( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadPyForest_comb" ),
        fNvars( 44 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "top1_m", "top2_m", "w1_m", "w2_m", "b1_pt", "b2_pt", "deltaRl1l2", "deltaRq1q2", "deltaRb1b2", "deltaRb1w1", "deltaRb2w2", "deltaPhil1l2", "deltaPhiq1q2", "deltaPhib1b2", "deltaPhiw1w2", "deltaPhit1t2", "q1b1_mass", "p1b2_mass", "deltaRb1q1", "deltaRb2p1", "deltaRb1top2", "deltaRb2top1", "deltaRb1w2", "deltaRb2w1", "mindeltaRb1q", "prob_chi2", "mindeltaRb2p", "deltaEtal1l2", "deltaEtaq1q2", "deltaEtab1b2", "deltaEtaw1w2", "deltaEtat1t2", "jet_CSV[0]", "jet_CSV[1]", "jet_CSV[2]", "jet_CSV[3]", "jet_CSV[4]", "jet_CSV[5]", "jet_QGL[0]", "jet_QGL[1]", "jet_QGL[2]", "jet_QGL[3]", "jet_QGL[4]", "jet_QGL[5]" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;
      fVmin[17] = 0;
      fVmax[17] = 0;
      fVmin[18] = 0;
      fVmax[18] = 0;
      fVmin[19] = 0;
      fVmax[19] = 0;
      fVmin[20] = 0;
      fVmax[20] = 0;
      fVmin[21] = 0;
      fVmax[21] = 0;
      fVmin[22] = 0;
      fVmax[22] = 0;
      fVmin[23] = 0;
      fVmax[23] = 0;
      fVmin[24] = 0;
      fVmax[24] = 0;
      fVmin[25] = 0;
      fVmax[25] = 0;
      fVmin[26] = 0;
      fVmax[26] = 0;
      fVmin[27] = 0;
      fVmax[27] = 0;
      fVmin[28] = 0;
      fVmax[28] = 0;
      fVmin[29] = 0;
      fVmax[29] = 0;
      fVmin[30] = 0;
      fVmax[30] = 0;
      fVmin[31] = 0;
      fVmax[31] = 0;
      fVmin[32] = 0;
      fVmax[32] = 0;
      fVmin[33] = 0;
      fVmax[33] = 0;
      fVmin[34] = 0;
      fVmax[34] = 0;
      fVmin[35] = 0;
      fVmax[35] = 0;
      fVmin[36] = 0;
      fVmax[36] = 0;
      fVmin[37] = 0;
      fVmax[37] = 0;
      fVmin[38] = 0;
      fVmax[38] = 0;
      fVmin[39] = 0;
      fVmax[39] = 0;
      fVmin[40] = 0;
      fVmax[40] = 0;
      fVmin[41] = 0;
      fVmax[41] = 0;
      fVmin[42] = 0;
      fVmax[42] = 0;
      fVmin[43] = 0;
      fVmax[43] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';
      fType[17] = 'F';
      fType[18] = 'F';
      fType[19] = 'F';
      fType[20] = 'F';
      fType[21] = 'F';
      fType[22] = 'F';
      fType[23] = 'F';
      fType[24] = 'F';
      fType[25] = 'F';
      fType[26] = 'F';
      fType[27] = 'F';
      fType[28] = 'F';
      fType[29] = 'F';
      fType[30] = 'F';
      fType[31] = 'F';
      fType[32] = 'F';
      fType[33] = 'F';
      fType[34] = 'F';
      fType[35] = 'F';
      fType[36] = 'F';
      fType[37] = 'F';
      fType[38] = 'F';
      fType[39] = 'F';
      fType[40] = 'F';
      fType[41] = 'F';
      fType[42] = 'F';
      fType[43] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadPyForest_comb() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[44];
   double fVmax[44];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[44];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   inline double ReadPyForest_comb::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
